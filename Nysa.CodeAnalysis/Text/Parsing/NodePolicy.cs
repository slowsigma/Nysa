using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Nysa.Text.Parsing;

/// <summary>
/// NodePolicy is used to affect the final shape of the syntax tree
/// generated from a successful parse. All grammar rules are marked
/// with the Default policy when one is not explicitly declared.
/// When a grammar rule is marked with a policy other than Default,
/// it will affect whether or not nodes generated by that grammar
/// rule will appear in the final tree and what will happen to a
/// node's contents (i.e., child nodes), if any. 
/// </summary>
public enum NodePolicy : Int32
{
    /// <summary>
    /// By default, each node created in the parsing process is
    /// kept in the final tree. 
    /// </summary>
    Default,                    // keep each node created by the grammar rule
    /// <summary>
    /// Remove any node created by this grammar rule regardless of content.
    /// </summary>
    Remove,                     // remove parse node regardless of content
    /// <summary>
    /// Remove only when the node has no content (i.e., no child nodes).
    /// </summary>
    RemoveEmpty,                // remove parse node when empty
    /// <summary>
    /// Give the contents of a node of this type to its parent in place
    /// of it maintaining all content position relative to siblings.
    /// </summary>
    Collapse,                   // collapse content to parent
    /// <summary>
    /// For any node of this type with only one child node, give that
    /// child node to the parent in place of it maintaining all content
    /// position relative to siblings.
    /// </summary>
    CollapseSingle,             // collapse content to parent when content is a single child
    /// <summary>
    /// For any node of this type with a parent of the same type, give
    /// the content to that parent in place of it maintaining all
    /// content position relative to siblings. Note, it is possible
    /// for the final tree to have a node with rollup policy as a
    /// child of a node of the same type. This can happen if the child
    /// node with the rollup policy was collapsed to the parent from a
    /// different type of node with a collapse style policy.
    /// </summary>
    Rollup                      // collapse content to parent of the same type
}
